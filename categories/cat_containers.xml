<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Adventurous Computing (Posts about containers)</title><link>https://blog.cyplo.net/</link><description></description><atom:link type="application/rss+xml" href="https://blog.cyplo.net/categories/cat_containers.xml" rel="self"></atom:link><language>en</language><lastBuildDate>Tue, 01 Jan 2019 13:25:30 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Running host programs in isolation inside one-off Docker containers</title><link>https://blog.cyplo.net/posts/2017/02/one-off-docker-runjessie.html</link><dc:creator>Cyryl Płotnicki</dc:creator><description>&lt;div&gt;&lt;p&gt;I am quite bad at remembering how to launch docker to have everything set up correctly. Hence the following - a script that launches any commandline specified in its arguments inside a new docker container. Current directory is mounted inside the container automatically, so the thing you are executing can have its local dependencies satisfied.&lt;/p&gt;
&lt;pre class="code bash"&gt;&lt;a name="rest_code_7976530f30d042cb8ca782acc5826eb4-1"&gt;&lt;/a&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;
&lt;a name="rest_code_7976530f30d042cb8ca782acc5826eb4-2"&gt;&lt;/a&gt;&lt;span class="nv"&gt;USERNAME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;whoami&lt;span class="sb"&gt;`&lt;/span&gt;
&lt;a name="rest_code_7976530f30d042cb8ca782acc5826eb4-3"&gt;&lt;/a&gt;&lt;span class="nv"&gt;MOUNT_PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"/mnt"&lt;/span&gt;
&lt;a name="rest_code_7976530f30d042cb8ca782acc5826eb4-4"&gt;&lt;/a&gt;&lt;span class="nv"&gt;CURRENT_DIRECTORY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;&lt;span class="nb"&gt;pwd&lt;/span&gt; -P&lt;span class="sb"&gt;`&lt;/span&gt; &lt;span class="c1"&gt;# untangle symbolic links if needed - SELinux needs the real path&lt;/span&gt;
&lt;a name="rest_code_7976530f30d042cb8ca782acc5826eb4-5"&gt;&lt;/a&gt;&lt;span class="nv"&gt;IMAGE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"debian:jessie"&lt;/span&gt;
&lt;a name="rest_code_7976530f30d042cb8ca782acc5826eb4-6"&gt;&lt;/a&gt;
&lt;a name="rest_code_7976530f30d042cb8ca782acc5826eb4-7"&gt;&lt;/a&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[[&lt;/span&gt; -z &lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="o"&gt;]]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
&lt;a name="rest_code_7976530f30d042cb8ca782acc5826eb4-8"&gt;&lt;/a&gt;    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"usage: `basename &lt;/span&gt;&lt;span class="nv"&gt;$0&lt;/span&gt;&lt;span class="s2"&gt;` command_to_run_inside_a_container"&lt;/span&gt;
&lt;a name="rest_code_7976530f30d042cb8ca782acc5826eb4-9"&gt;&lt;/a&gt;    &lt;span class="nb"&gt;exit&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;
&lt;a name="rest_code_7976530f30d042cb8ca782acc5826eb4-10"&gt;&lt;/a&gt;&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;a name="rest_code_7976530f30d042cb8ca782acc5826eb4-11"&gt;&lt;/a&gt;
&lt;a name="rest_code_7976530f30d042cb8ca782acc5826eb4-12"&gt;&lt;/a&gt;&lt;span class="nv"&gt;RESOLVED_ARGUMENTS&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$@&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;a name="rest_code_7976530f30d042cb8ca782acc5826eb4-13"&gt;&lt;/a&gt;docker run -i -t -v &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$CURRENT_DIRECTORY&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;:&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$MOUNT_PATH&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;:Z &lt;span class="nv"&gt;$IMAGE&lt;/span&gt; bash -c &lt;span class="s2"&gt;"useradd -M -d '&lt;/span&gt;&lt;span class="nv"&gt;$MOUNT_PATH&lt;/span&gt;&lt;span class="s2"&gt;' &lt;/span&gt;&lt;span class="nv"&gt;$USERNAME&lt;/span&gt;&lt;span class="s2"&gt; &amp;amp;&amp;amp; cd '&lt;/span&gt;&lt;span class="nv"&gt;$MOUNT_PATH&lt;/span&gt;&lt;span class="s2"&gt;' &amp;amp;&amp;amp; bash -c '&lt;/span&gt;&lt;span class="nv"&gt;$RESOLVED_ARGUMENTS&lt;/span&gt;&lt;span class="s2"&gt;'"&lt;/span&gt;
&lt;a name="rest_code_7976530f30d042cb8ca782acc5826eb4-14"&gt;&lt;/a&gt;
&lt;a name="rest_code_7976530f30d042cb8ca782acc5826eb4-15"&gt;&lt;/a&gt;&lt;span class="c1"&gt;# restore SELinux context for the current directory&lt;/span&gt;
&lt;a name="rest_code_7976530f30d042cb8ca782acc5826eb4-16"&gt;&lt;/a&gt;&lt;span class="nv"&gt;restorecon_path&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sb"&gt;`&lt;/span&gt;which restorecon&lt;span class="sb"&gt;`&lt;/span&gt;
&lt;a name="rest_code_7976530f30d042cb8ca782acc5826eb4-17"&gt;&lt;/a&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[[&lt;/span&gt; -x &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$restorecon_path&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;]]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
&lt;a name="rest_code_7976530f30d042cb8ca782acc5826eb4-18"&gt;&lt;/a&gt;    restorecon -R &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$CURRENT_DIRECTORY&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
&lt;a name="rest_code_7976530f30d042cb8ca782acc5826eb4-19"&gt;&lt;/a&gt;&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;I use vanilla Debian Jessie as a run platform there, mostly because this is what most of my servers run.
The script covers setting up SELinux and mounting the directory from which it is run as &lt;tt class="docutils literal"&gt;/mnt&lt;/tt&gt; inside the container while also having the default non-root user added.&lt;/p&gt;
&lt;p&gt;Run Jessie, run !&lt;/p&gt;&lt;/div&gt;</description><category>container</category><category>docker</category><category>jessie</category><category>linux</category><guid>https://blog.cyplo.net/posts/2017/02/one-off-docker-runjessie.html</guid><pubDate>Fri, 17 Feb 2017 22:08:46 GMT</pubDate></item><item><title>Using ad hoc Docker volumes on SELinux systems</title><link>https://blog.cyplo.net/posts/2016/12/ad-hoc-docker-volumes-selinux.html</link><dc:creator>Cyryl Płotnicki</dc:creator><description>&lt;div&gt;&lt;p&gt;I've recently tried running some quick Docker commands using host's directory as a volume:&lt;/p&gt;
&lt;pre class="code console"&gt;&lt;a name="rest_code_5ba39377fed240629e93fe87d7c465e7-1"&gt;&lt;/a&gt;&lt;span class="go"&gt;docker run -i -t -v `pwd`:/mnt debian:jessie bash -c "ls -hal /mnt"&lt;/span&gt;
&lt;a name="rest_code_5ba39377fed240629e93fe87d7c465e7-2"&gt;&lt;/a&gt;&lt;span class="go"&gt;ls: cannot open directory /mnt: Permission denied&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;I use Fedora as my main OS, which, it turns out, has some pretty nice SELinux settings. These deny access from inside the container to the outside.
Said Fedora consists mostly of almost-newest-but-stable everything though, which makes Docker to be in a fairly recent version.
A version that understands how to change a SELinux context for the directory we're mounting, by itself !
You need at least Docker v1.7 for this.&lt;/p&gt;
&lt;pre class="code console"&gt;&lt;a name="rest_code_96656162fb1a4523b2f37aa591792426-1"&gt;&lt;/a&gt;&lt;span class="go"&gt;docker run -i -t -v `pwd`:/mnt:Z debian:jessie bash -c "ls -hal /mnt"&lt;/span&gt;
&lt;a name="rest_code_96656162fb1a4523b2f37aa591792426-2"&gt;&lt;/a&gt;&lt;span class="go"&gt;total 8.0K&lt;/span&gt;
&lt;a name="rest_code_96656162fb1a4523b2f37aa591792426-3"&gt;&lt;/a&gt;&lt;span class="go"&gt;drwxrwxr-x.  2 1000 1000 4.0K Dec 30 18:34 .&lt;/span&gt;
&lt;a name="rest_code_96656162fb1a4523b2f37aa591792426-4"&gt;&lt;/a&gt;&lt;span class="go"&gt;drwxr-xr-x. 21 root root  242 Dec 30 19:07 ..&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;Please notice the capital &lt;cite&gt;Z&lt;/cite&gt; as a mount parameter.
And that is it. Mostly. Some cleanup remains, as docker leaves the host's directory with a changed SELinux context.
To restore it you need to&lt;/p&gt;
&lt;pre class="code console"&gt;&lt;a name="rest_code_eb3525dd0ef04e1e8a1f3428f2e23a3f-1"&gt;&lt;/a&gt;&lt;span class="go"&gt;restorecon -R `pwd`&lt;/span&gt;
&lt;/pre&gt;&lt;p&gt;Or use any other path you'd like instead of &lt;cite&gt;`pwd`&lt;/cite&gt; in the examples above.
Happy dockerizing !&lt;/p&gt;&lt;/div&gt;</description><category>container</category><category>data</category><category>docker</category><category>permissions</category><category>selinux</category><category>volume</category><guid>https://blog.cyplo.net/posts/2016/12/ad-hoc-docker-volumes-selinux.html</guid><pubDate>Fri, 30 Dec 2016 18:28:50 GMT</pubDate></item></channel></rss>